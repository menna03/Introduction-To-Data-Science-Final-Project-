# -*- coding: utf-8 -*-
"""Introduction to data science project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f6q-Tacg61uir9T0MCHyi8y4F5my4b_q
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from sklearn.preprocessing import LabelEncoder
from sklearn.cluster import KMeans
from matplotlib.ticker import PercentFormatter

fuelData = pd.read_csv('fuel.csv')
weatherData= pd.read_csv('weather.csv')
salesData = pd.read_csv('sales.csv')

fuel=pd.DataFrame(fuelData)
weather=pd.DataFrame(weatherData)
sales=pd.DataFrame(salesData)

"""# Question One [Data Cleaning]

## fuel data cleaning
"""

fuel.head(10)

fuel.isna().sum()* 100 / len(fuel)
#check Nans

negative_num = list(filter(lambda x: (x<0),fuel['Fuel_Price'] ))
negative_num
#check negative values in fuel price

fuel
#just to view the data

fuel["Date"]=pd.to_datetime(fuel['Date'])
fuel["Date"]
#just a check that it reads as dates

"""## Weather data cleaning"""

weather.head(10)

weather.isna().sum()* 100 / len(weather)
#check Nans

weather
#just to view the data

weather["Date"]=pd.to_datetime(weather['Date'])
weather["Date"]
#just a check that it reads as dates

"""## Sales data cleaning"""

sales.head(10)

sales.isna().sum()* 100 / len(sales)
#check Nans

sales['Weekly_Sales']!=0
#check if theres sales =0

negative_num = list(filter(lambda x: (x<0),sales['Weekly_Sales'] ))
negative_num.count
#check negative values in weekly Sales price

sales['Weekly_Sales'] = np.where(sales['Weekly_Sales'] < 0, np.nan , sales['Weekly_Sales'])
sales['Weekly_Sales']
#removes weekly sales negative values with nans

sales.isna().sum()* 100 / len(sales)
#check Nans

sales=sales.dropna()
sales
#dropping this nan values

sales.isna().sum()* 100 / len(sales)
#check Nans again to mae sure that the function workes

negative_num = list(filter(lambda x: (x<0),sales['Weekly_Sales'] ))
print(negative_num)
#check negative values in weekly Sales price

sales
#just to view the data

sales["Date"]=pd.to_datetime(sales['Date'])
sales["Date"]
#just a check that it reads as dates

"""## describing the data"""

fuel.describe()
#neglect the store describtion becuse it doesnt have meaning
#the fuel prices is near from each other

weather.describe()
#neglect the store describtion becuse it doesnt have meaning
#the range of the weather data is big compared to the fuel prices data

sales.describe()
#neglect the store describtion becuse it doesnt have meaning
#the range is so big and the mean also

"""## Merging the Data"""

superMerge0= fuel.merge(weather, on=['Date','Store'])
superMerge= superMerge0.merge(sales, on=['Date','Store'])
superMerge

superMerge.shape

superMerge.duplicated().sum()
#check for duplicates

superMerge.dtypes
#to see the data types

fig, ax = plt.subplots(figsize=(15, 5))
plt.title('Fuel_Price')
sns.boxplot(data = superMerge, x = "Fuel_Price");
plt.show()

fig, ax = plt.subplots(figsize=(15, 5))

plt.title('Temperature')
sns.boxplot(data = superMerge, x = "Temperature");
plt.show()

fig, ax = plt.subplots(figsize=(15, 5))
plt.title('Category')
sns.boxplot(data = superMerge, x = "Category");
plt.show()

fig, ax = plt.subplots(figsize=(15, 5))
plt.title('Weekly_Sales')
sns.boxplot(data = superMerge, x = "Weekly_Sales");
plt.show()

superMerge.isna().sum()* 100 / len(superMerge)

"""# Question Two [Visualization]"""

# 1. make a chart to illustrate if weekly sales are increasing or decreasing over time.
plt.figure(figsize=(20,7))
salesChange = superMerge.groupby('Date')['Weekly_Sales'].sum()
plt.plot(salesChange.index, salesChange.values)
plt.title('Weekly sales over time')
plt.xlabel('Date')
plt.ylabel('Weekly sales')
plt.xticks(rotation=60)
plt.show()

# 2. Make a chart to show how much each brand sells.
plt.figure(figsize=(20,7))
brand_sales = superMerge.groupby('Category')['Weekly_Sales'].sum()
plt.bar(brand_sales.index,sorted( brand_sales.values))
plt.title('Brand Sales')
plt.xlabel('Brand')
plt.ylabel('Total Sales')
plt.show()

# 3.Determine the top ten selling stores.
store_sales = sales.groupby("Store")["Weekly_Sales"].sum()
top_ten_stores = store_sales.sort_values(ascending=False).head(10)
top_ten_stores

#4. Make a histogram to show the top 10 stores sales.
plt.figure(figsize=(20,7))
top_ten_stores.plot(kind="bar")
plt.xlabel("Store")
plt.ylabel("Sales")
plt.title("Top 10 Selling Stores")
plt.ylim(200_000_000)
plt.xticks(rotation=0)
plt.grid()
plt.show()

# 5. Create a chart that compares average weekly sales for the top ten selling stores
#during holidays and non-holidays.
HolidaySales = superMerge[superMerge['Holiday']==True]
NonHolidaySales = superMerge[superMerge['Holiday']==False]
HolidaySalesAvg = HolidaySales.groupby('Store')['Weekly_Sales'].mean().nlargest(10)
NonHolidaySalesAvg = NonHolidaySales.groupby('Store')['Weekly_Sales'].mean().nlargest(10)
combined_data = pd.concat([HolidaySalesAvg, NonHolidaySalesAvg], axis=1)
combined_data.columns = ['Holiday Avg Sales', 'Non-Holiday Avg Sales']

combined_data.plot(kind='bar',figsize=(10, 6))
plt.title('Average Weekly Sales for Top Ten Stores During Holidays and Non-Holidays')
plt.xlabel('Store')
plt.ylabel('Average Weekly Sales')
plt.ylim(20_000)
plt.xticks(rotation=0)
plt.show()

#6. Create a chart that displays the average weekly sales for each brand department
#for the top 10 selling stores.
Top10Stores = superMerge.groupby('Store')['Weekly_Sales'].sum().nlargest(10).index
sales_data = superMerge[superMerge['Store'].isin(Top10Stores)]
AvgSales = superMerge.groupby(['Category'])['Weekly_Sales'].mean()
AvgSales.plot(kind='bar', figsize=(15, 7))
plt.title('Average Weekly Sales for Brand Departments in Top 10 Selling Stores')
plt.xlabel('Brand Department')
plt.ylabel('Average Weekly Sales')
plt.xticks(rotation=90)
plt.show()

# 7.  Make a line chart to show the relationship between weekly sales and weather
#    Temperature.
salesGrpDate=sales.groupby(['Date']).mean()
salesGrpDate=salesGrpDate.drop(columns=['Store', 'Category','Holiday'])
salesGrpDate=pd.DataFrame(salesGrpDate)
salesGrpDate

weatherGrpDate=weather.groupby(['Date']).mean()
weatherGrpDate=weatherGrpDate.drop(columns=['Store'])
weatherGrpDate=pd.DataFrame(weatherGrpDate)
weatherGrpDate

weatherSalesMerge=pd.merge(salesGrpDate,weatherGrpDate, how='inner', left_index=True, right_index=True)
weatherSalesMerge

plt.figure(figsize=(20,7))
plt.plot(sorted(weatherSalesMerge['Temperature']),weatherSalesMerge['Weekly_Sales'])
plt.title('Weekly sales and weather Temperature')
plt.xlabel('Temperature')
plt.ylabel('Weekly Sales')
plt.grid()
plt.show()

FuelGrpDate=fuel.groupby(['Date']).mean()
FuelGrpDate=fuel.drop(columns=['Store'])
FuelGrpDate=pd.DataFrame(FuelGrpDate)
FuelGrpDate

FuelWeatherSalesMerge = pd.merge(FuelGrpDate, weatherSalesMerge, how='inner', on='Date')
FuelWeatherSalesMerge=FuelWeatherSalesMerge.drop_duplicates()

FuelWeatherSalesMerge

#8. Make a line chart to show the relationship between the cost of fuel and weather
#   weekly sales.


FuelWeatherSalesMerge = superMerge[['Date', 'Fuel_Price', 'Weekly_Sales', 'Temperature']]


plt.plot(superMerge['Fuel_Price'], superMerge['Weekly_Sales'])
plt.title('Weekly sales and weather Temperature and fuel')
plt.xlabel('Weekly Sales')
plt.ylabel('Temperature')
plt.show()

#9. For each possible pair, create a pair plot to show different correlations.
sns.pairplot(superMerge)

"""

# LinearRegression"""

superMerge['year']= superMerge['Date'].dt.year
superMerge['month']= superMerge['Date'].dt.month
superMerge['day']= superMerge['Date'].dt.day
superMerge
#Will need the splited columns in modeling

superMerge.head()

superMerge.columns

#df1=superMerge[['Store', 'Fuel_Price',  'year']]
#df2=superMerge['Weekly_Sales']
#15155.831358481286 <- if we don't want to put all the features but it will be less acurate bit not by alot

df1=superMerge[['Store', 'Fuel_Price', 'Temperature', 'Category',
       'Holiday', 'year', 'month']]
df2=superMerge['Weekly_Sales']

#15150.693231366273

X =df1
y = df2

X_train, X_test, y_train, y_test = train_test_split(X, y,
                            test_size=0.2, random_state=0)

from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)
r2_score(y_test, y_pred)

mean_absolute_error(y_test, y_pred)

mean_squared_error(y_test, y_pred)

"""# Some Drawing to understand the model more"""

from mpl_toolkits.mplot3d import Axes3D

# Define your data
x =  superMerge[ 'Fuel_Price']
y = superMerge['Weekly_Sales']
z =  superMerge[ 'Temperature']

# Create a figure and subplots
fig = plt.figure(figsize=(12, 4))
ax1 = fig.add_subplot(131, projection='3d')
ax2 = fig.add_subplot(132, projection='3d')
ax3 = fig.add_subplot(133, projection='3d')
axes = [ax1, ax2, ax3]

# Iterate over subplots and plot the data
for ax in axes:
    ax.scatter(x, y, z, c='b', marker='o', alpha=0.5)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

# Set the viewing angles for each subplot
ax1.view_init(elev=28, azim=120)
ax2.view_init(elev=4, azim=114)
ax3.view_init(elev=60, azim=165)

# Add titles and adjust layout
ax1.set_title('Subplot 1')
ax2.set_title('Subplot 2')
ax3.set_title('Subplot 3')
fig.suptitle('3D Scatter Plot')
fig.tight_layout()

# Show the plot
plt.show()

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

x = superMerge['Category']
y = superMerge['Fuel_Price']
z = superMerge['Weekly_Sales']
c = superMerge['Temperature']

img = ax.scatter(x, y, z, c=c, cmap='hot')
fig.colorbar(img)
ax.set_xlabel('Weekly Sales')
ax.set_ylabel('Category')
ax.set_zlabel('Temperature')

plt.show()

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import seaborn as sns

def plot_3d_pairplot(data, features):
    num_features = len(features)
    fig = plt.figure(figsize=(10, 10))

    index = 1
    for i in range(num_features):
        for j in range(i+1, num_features):
            ax = fig.add_subplot(num_features-1, num_features-1, index, projection='3d')
            ax.scatter(data[features[i]], data[features[j]], data[features[(i+j) % num_features]], c=data[features[(i+j+1) % num_features]], cmap='hot')
            ax.set_xlabel(features[i])
            ax.set_ylabel(features[j])
            ax.set_zlabel(features[(i+j) % num_features])
            index += 1

    plt.tight_layout()
    plt.show()

# Define the list of features to visualize
features = ['Temperature', 'Fuel_Price', 'Weekly_Sales', 'Category']

# Generate the 3D pairplot
plot_3d_pairplot(superMerge, features)



"""# Decision Tree Classifier"""

from sklearn.preprocessing import LabelEncoder
# Decision Tree Classifier
from sklearn.tree import DecisionTreeClassifier
# Plot Decision Tree
from sklearn import tree
import matplotlib.pyplot as plt
# Evaluation
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score
from sklearn.metrics import roc_curve, roc_auc_score

DT=pd.DataFrame(superMerge)
DT = superMerge.drop('Date', axis=1)

DT.head()

DT.columns

DT['Holiday'].value_counts()

DT['Holiday'] = DT['Holiday'].replace(False, 0)
DT['Holiday'] = DT['Holiday'].replace(True, 1)

DT[ 'Holiday']=pd.to_numeric(DT[ 'Holiday'], errors='coerce')

DT.head()

X = DT.drop(columns = ['Holiday'])
y = DT['Holiday'].values
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size = 0.30, random_state = 40, stratify=y)

# Train and fit the model
dt_clf = DecisionTreeClassifier(max_depth = 3)
dt_clf.fit(X_train, y_train)

dt_pred = dt_clf.predict(X_test)
print(dt_pred)

#plt the figure, setting a black background
plt.figure(figsize=(30,10), facecolor ='white')
#create the tree plot
a = tree.plot_tree(dt_clf,
                   #use the feature names stored
                   feature_names = DT.columns[:-1],
                   #use the class names stored
                   class_names = ['Holiday', 'No Holiday'],
                   rounded = True,
                   filled = True,
                   fontsize=14)
#show the plot
plt.show()

accuracy_score(y_test, dt_pred)

dt_pred_train = dt_clf.predict(X_train)
dt_pred_train
accuracy_score(y_train, dt_pred_train)

"""#Random Forest Regressor"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

X=superMerge[['Store', 'Fuel_Price', 'Temperature', 'Category',
       'Holiday', 'year', 'month']]
y=superMerge['Weekly_Sales']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

rf_regressor = RandomForestRegressor(random_state=0)
rf_regressor.fit(X_train, y_train)

r2 = r2_score(y_test, y_pred)
r2

y_pred = rf_regressor.predict(X_test)
y_pred

mse = mean_squared_error(y_test, y_pred)
mse

"""we can clearly see that the Random Forest is more accurate by a lot as the R2 hear is 96 and in Linear Regression is 0.03

# kmeans
"""

import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

X = superMerge[['Weekly_Sales','Category','Store']]

inertias = []
clusters = range(1, 11)

for i in clusters:
    kmeans = KMeans(n_clusters=i)
    kmeans.fit(X)
    inertias.append(kmeans.inertia_)

fig = sns.lineplot(x=clusters, y=inertias)
fig.set(title=f'Elbow Method for {len(clusters)} clusters')
fig.set_xlabel('Number of clusters')
fig.set_ylabel('Within Cluster Sum of Squares (WCSS)')
plt.show()

"""we can see the graph is between 3 and 2

so we will choose 2 or 3
"""

kmeans = KMeans(n_clusters=3)

kmeans.fit(X)
preds = kmeans.predict(X)
grouped_data = superMerge.groupby('Store')['Category'].sum()

sns.scatterplot(x=grouped_data, y=superMerge['Weekly_Sales'], hue=preds)

kmeans = KMeans(n_clusters=2)
kmeans.fit(X)
preds = kmeans.predict(X)
grouped_data = superMerge.groupby('Store')['Category'].sum()

sns.scatterplot(x=grouped_data, y=superMerge['Weekly_Sales'], hue=preds)

"""# ![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYsAAAIKCAMAAADlOpNZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABjUExURQAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////5pFDaAAAAAgdFJOUwAIEBggKDA4QEhQWGBocHiAh4+Xn6evt7/Hz9ff5+/3v+H4wgAAAAlwSFlzAAAXEQAAFxEByibzPwAAISRJREFUeF7tnetC6joQhbl4KRfdVVQQub3/U57MrJU0La2KB0R0fT/ObmtJk1nJZJJymJ4QQgghhBBCCCGEEEIIIYQQQgghhPjlDBcV8/LfNa5OeGWEU2OKK/M+z8XRudrVeZ3a1f4bztbJ8sMtrtzxXByfpha7XWmXb3nyz28KzHC+4Kk4AftaQIxHHG+HflfvhqdXOBWnoEWL3U243l/h+Bm3veJMHuqUUIvHMvCCYwyMgie3djLBsTzUSaEW8D03Gz/BWOAMsQyH/bUfykOdlpoWvSc/efHjAQTYhcCqxJE81Gmpa4Gx8IiTkZ+EuJbxLDzU9HWXLzvE8ahpMcCEPfaTXu/Zz3aPmEfgoTBE4h3imGRaDCZY4b3iL2F9x2nC/wsPNcDJyv8ujgu1yHgd8E8pfHLgoei3dtU94mg0tVjf5xtOMcpNMRRv3/iJOC5NLVaPttKLDBHkBmIMBXXS1og4Ivs+Cks9MuW1tMobWNj7wBNxVKjF62Kx4HqiLsbCr+SrvH7BA3FkqIXbelDM/SS3PFZ/ipu+g1yLtCOYTQfS4vuoa8GpmZuzhrT4PhpaYLWX7cdKi++jrgWXcnOcGXta3D4vnvhWXBwXajEpAuMZtzu4OWg0tfCl+NZfaogjQy3qZKZuaNGHWmnLShyRNi3y9UVDi/idBO1HnYAWLXIpmlpc+6n2o07Cnhar+tu75nyBLyHMeCaOSV2L1+fmK7umFtcmxou+PPgzKApFUUIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBDiL3Jjyd3Le559gttD00DgCVOeiW6QZLH6TfsPmG52u/mQJ58DT/hJqfqH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)"""